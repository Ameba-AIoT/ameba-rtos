include_guard(GLOBAL)

# color define
string(ASCII 27 _Esc)
set(C_COLOR_RESET "${_Esc}[0m")
set(C_COLOR_RED "${_Esc}[1;31m")
set(C_COLOR_GREEN "${_Esc}[1;32m")
set(C_COLOR_YELLOW "${_Esc}[1;33m")
set(C_COLOR_BLUE "${_Esc}[1;34m")
set(C_COLOR_PURPLE "${_Esc}[1;35m")
set(C_COLOR_CYAN "${_Esc}[1;36m")
unset(_Esc)

macro(_ameba_log_prefix_get) # MUST be macro
    if (CMAKE_CURRENT_FUNCTION_LIST_FILE)
        set(_tmp_fname ${CMAKE_CURRENT_FUNCTION_LIST_FILE})
        set(_tmp_fpath ${CMAKE_CURRENT_FUNCTION_LIST_DIR})
        set(_tmp_fmod ${CMAKE_CURRENT_FUNCTION})
        # set(_tmp_fline ${CMAKE_CURRENT_FUNCTION_LIST_LINE})
    else()
        set(_tmp_fname ${CMAKE_CURRENT_LIST_FILE})
        set(_tmp_fpath ${CMAKE_CURRENT_LIST_DIR})
        set(_tmp_fmod)
        # set(_tmp_fline ${CMAKE_CURRENT_LIST_LINE})
    endif()
    get_filename_component(_file_dir ${_tmp_fpath} NAME)
    get_filename_component(_file_name ${_tmp_fname} NAME)
    set(_tmp_log_prefix "${_file_dir}/${_file_name}")
    if (_tmp_fmod)
        set(_tmp_log_prefix "${_tmp_log_prefix}|${_tmp_fmod}")
    endif()
    if (t_USER_CUSTOM_LOG_PREFIX)
        set(_tmp_log_prefix "${_tmp_log_prefix} [${t_USER_CUSTOM_LOG_PREFIX}]")
    endif()

    unset(_file_name)
    unset(_file_dir)
    # unset(_tmp_fline)
    unset(_tmp_fmod)
    unset(_tmp_fpath)
    unset(_tmp_fname)
endmacro()

macro(_ameba_assert_str_equal str1 str2)
    if (NOT "${str1}" STREQUAL "${str2}")
        message(FATAL_ERROR "_ameba_assert_str_equal failed: [${str1}] vs [${str2}]")
    endif()
endmacro()

macro(_ameba_assert_str_not_equal str1 str2)
    if ("${str1}" STREQUAL "${str2}")
        message(FATAL_ERROR "_ameba_assert_str_not_equal failed: [${str1}] vs [${str2}]")
    endif()
endmacro()

macro(_ameba_assert_defined name)
    if (NOT DEFINED "${name}")
        message(FATAL_ERROR "_ameba_assert_defined failed")
    endif()
endmacro()

macro(_ameba_assert_not_defined name)
    if (DEFINED "${name}")
        message(FATAL_ERROR "_ameba_assert_not_defined failed")
    endif()
endmacro()

macro(_ameba_list_contain list_name value result)
    if (NOT ${list_name})
        set(${result} FALSE)
    endif()

    # Find the value in the list
    list(FIND ${list_name} ${value} index)

    # Check if the value is found
    if(index GREATER -1)
        set(${result} TRUE)
    else()
        set(${result} FALSE)
    endif()
endmacro()

# remove key word and the arg following key word(usually to delete oneValueArgs)
# Usage:
#   _ameba_list_remove_key(<list_name> <key>)
macro(_ameba_list_remove_key list_name key)
    # set(options)
    # set(oneValueArgs)
    # set(multiValueArgs p_ELSE)

    # cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    set(_tmp_list)
    set(_tmp_skip_next_arg FALSE)
    foreach(arg IN LISTS ${list_name})
        if (_tmp_skip_next_arg)
            set(_tmp_skip_next_arg FALSE)
        else()
            if("${arg}_" STREQUAL "${key}_")
                set(_tmp_skip_next_arg TRUE)
            else()
                list(APPEND _tmp_list "${arg}")
            endif()
        endif()
    endforeach()
    set(${list_name} ${_tmp_list})
    unset(_tmp_skip_next_arg)
    unset(_tmp_list)
endmacro()

# remove key and followings(usually to delete multiValueArgs), but not the multi values following p_KEEP
# Usage:
#   _ameba_list_remove_key_and_followings(<list_name> <key> [p_KEEP <keepvalue> ...])
macro(_ameba_list_remove_key_and_followings list_name key)
    set(options)
    set(oneValueArgs)
    set(multiValueArgs p_KEEP)

    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    set(_tmp_list)
    set(_tmp_skip_next_arg FALSE)
    set(_tmp_find_keep FALSE)
    if(${list_name} STREQUAL "ARGN")
        message(FATAL_ERROR "list name should not be ARGN")
    endif()
    foreach(arg IN LISTS ${list_name})
        if ("${arg}_" STREQUAL "_")
            continue()
        endif()
        _ameba_list_contain(ARG_p_KEEP ${arg} is_contained)
        if (${is_contained})
            set(_tmp_find_keep TRUE)
        endif()

        if (_tmp_find_keep)
            list(APPEND _tmp_list "${arg}")
        else()
            if (NOT _tmp_skip_next_arg)
                if(${arg} STREQUAL "${key}")
                    set(_tmp_skip_next_arg TRUE)
                else()
                    list(APPEND _tmp_list "${arg}")
                endif()
            endif()
        endif()
    endforeach()
    set(${list_name} ${_tmp_list})
    unset(_tmp_find_keep)
    unset(_tmp_skip_next_arg)
    unset(_tmp_list)
endmacro()

macro(_ameba_list_remove_before_keys list_name)
    set(options)
    set(oneValueArgs)
    set(multiValueArgs p_KEYS)
    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    set(_tmp_list)
    set(_tmp_find_key FALSE)
    if(${list_name} STREQUAL "ARGN")
        message(FATAL_ERROR "list name should not be ARGN")
    endif()
    foreach(arg IN LISTS ${list_name})
        if ("${arg}_" STREQUAL "_")
            continue()
        endif()

        if (_tmp_find_key)
            list(APPEND _tmp_list ${arg})
        else()
            _ameba_list_contain(ARG_p_KEYS ${arg} is_contained)
            if (${is_contained})
                set(_tmp_find_key TRUE)
                list(APPEND _tmp_list ${arg})
            endif()
        endif()
    endforeach()
    set(${list_name} ${_tmp_list})
    unset(_tmp_find_key)
    unset(_tmp_list)
endmacro()


# get target property to result, property should be [sources/compile_options/compile_defines/includes]
# if target is INTERFACE_LINK_LIBRARIES, than recursively get the property from the INTERFACE_LIBRARY, otherwise, just get the property from the target
# Usage:
#   ameba_target_get_property_recursive(<target> <property> <result>)
function(ameba_target_get_property_recursive target property result)
    if(${property} STREQUAL sources)
        set(property_name "INTERFACE_SOURCES")
    elseif(${property} STREQUAL compile_options)
        set(property_name "INTERFACE_COMPILE_OPTIONS")
    elseif(${property} STREQUAL compile_defines)
        set(property_name "INTERFACE_COMPILE_DEFINITIONS")
    elseif(${property} STREQUAL includes)
        set(property_name "INTERFACE_INCLUDE_DIRECTORIES")
    else()
        message(FATAL_ERROR "un-support property type for ameba_target_get_property_recursive: ${property}")
    endif()

    set(tmp_result)
    get_target_property(res ${target} ${property_name})
    if(res)
        list(APPEND tmp_result ${res})
    endif()

    get_target_property(libs ${target} INTERFACE_LINK_LIBRARIES)
    foreach(lib ${libs})
        if (TARGET ${lib})
            get_target_property(TARGET_TYPE ${lib} TYPE)
            if(${TARGET_TYPE} STREQUAL "INTERFACE_LIBRARY")
                ameba_target_get_property_recursive(${lib} ${property} res)
                if (res)
                    list(APPEND tmp_result ${res})
                endif()
            endif()
        endif()
    endforeach()

    set(${result} ${tmp_result} PARENT_SCOPE)
endfunction()
