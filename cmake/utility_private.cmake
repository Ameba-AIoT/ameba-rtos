include_guard(GLOBAL)

# color define
string(ASCII 27 _Esc)
set(C_COLOR_RESET "${_Esc}[0m")
set(C_COLOR_RED "${_Esc}[1;31m")
set(C_COLOR_GREEN "${_Esc}[1;32m")
set(C_COLOR_YELLOW "${_Esc}[1;33m")
set(C_COLOR_BLUE "${_Esc}[1;34m")
set(C_COLOR_PURPLE "${_Esc}[1;35m")
set(C_COLOR_CYAN "${_Esc}[1;36m")
unset(_Esc)


# generate random string. Can be used for avoiding naming conflict/override
# Usage:
#   ameba_random_string(<condition> <var> <description> <value> [p_ELSE <elsevalue>])
function(ameba_random_string result)
    set(oneValueArgs p_LENGTH p_PREFIX p_SUFFIX)
    cmake_parse_arguments(ARG "" "${oneValueArgs}" "" ${ARGN})
    if(NOT DEFINED ARG_p_LENGTH)
        set(ARG_p_LENGTH 5) # Default length: 5
    endif()

    set(LETTER_SET "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
    set(NUMBER_SET "0123456789")

    math(EXPR part2_len "${ARG_p_LENGTH} - 1")
    string(RANDOM LENGTH 1 ALPHABET "${LETTER_SET}" PART1)
    if (part2_len GREATER 1)
        string(RANDOM LENGTH ${part2_len} ALPHABET "${LETTER_SET}${NUMBER_SET}" PART2)
    else()
        set(PART2 "")
    endif()

    set(${result} "${ARG_p_PREFIX}${PART1}${PART2}${ARG_p_SUFFIX}" PARENT_SCOPE)
endfunction()

#WARNING: ameba_generate_log_prefix MUST be a macor to get the right info
macro(ameba_generate_log_prefix result)
    if (CMAKE_CURRENT_FUNCTION_LIST_FILE)
        set(ameba_generate_log_prefix_tmp_fname ${CMAKE_CURRENT_FUNCTION_LIST_FILE})
        set(ameba_generate_log_prefix_tmp_fpath ${CMAKE_CURRENT_FUNCTION_LIST_DIR})
        set(ameba_generate_log_prefix_tmp_fmod ${CMAKE_CURRENT_FUNCTION})
        # set(_tmp_fline ${CMAKE_CURRENT_FUNCTION_LIST_LINE})
    else()
        set(ameba_generate_log_prefix_tmp_fname ${CMAKE_CURRENT_LIST_FILE})
        set(ameba_generate_log_prefix_tmp_fpath ${CMAKE_CURRENT_LIST_DIR})
        set(ameba_generate_log_prefix_tmp_fmod)
        # set(_tmp_fline ${CMAKE_CURRENT_LIST_LINE})
    endif()
    get_filename_component(_file_dir ${ameba_generate_log_prefix_tmp_fpath} NAME)
    get_filename_component(_file_name ${ameba_generate_log_prefix_tmp_fname} NAME)
    set(ameba_generate_log_prefix_full_log_prefix "${_file_dir}/${_file_name}")
    if (ameba_generate_log_prefix_tmp_fmod)
        set(ameba_generate_log_prefix_full_log_prefix "${ameba_generate_log_prefix_full_log_prefix}|${ameba_generate_log_prefix_tmp_fmod}")
    endif()
    if (v_USER_CUSTOM_LOG_PREFIX)
        set(ameba_generate_log_prefix_full_log_prefix "${ameba_generate_log_prefix_full_log_prefix} [${v_USER_CUSTOM_LOG_PREFIX}]")
    endif()
    set(${result} ${ameba_generate_log_prefix_full_log_prefix})
endmacro()

macro(_ameba_assert_str_equal str1 str2)
    if (NOT "${str1}" STREQUAL "${str2}")
        message(FATAL_ERROR "_ameba_assert_str_equal failed: [${str1}] vs [${str2}]")
    endif()
endmacro()

macro(_ameba_assert_str_not_equal str1 str2)
    if ("${str1}" STREQUAL "${str2}")
        message(FATAL_ERROR "_ameba_assert_str_not_equal failed: [${str1}] vs [${str2}]")
    endif()
endmacro()

macro(_ameba_assert_defined name)
    if (NOT DEFINED "${name}")
        message(FATAL_ERROR "_ameba_assert_defined failed")
    endif()
endmacro()

macro(_ameba_assert_not_defined name)
    if (DEFINED "${name}")
        message(FATAL_ERROR "_ameba_assert_not_defined failed")
    endif()
endmacro()

function(_ameba_list_contain list_name value result)
    if (NOT ${list_name})
        set(${result} FALSE PARENT_SCOPE)
    endif()

    # Find the value in the list
    list(FIND ${list_name} ${value} index)

    # Check if the value is found
    if(index GREATER -1)
        set(${result} TRUE PARENT_SCOPE)
    else()
        set(${result} FALSE PARENT_SCOPE)
    endif()
endfunction()

# remove key word and the arg following key word(usually to delete oneValueArgs)
# Usage:
#   _ameba_list_remove_key(<list_name> <key>)
macro(_ameba_list_remove_key list_name key)
    # set(options)
    # set(oneValueArgs)
    # set(multiValueArgs p_ELSE)

    # cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    set(_tmp_list)
    set(_tmp_skip_next_arg FALSE)
    foreach(arg IN LISTS ${list_name})
        if (_tmp_skip_next_arg)
            set(_tmp_skip_next_arg FALSE)
        else()
            if("${arg}_" STREQUAL "${key}_")
                set(_tmp_skip_next_arg TRUE)
            else()
                list(APPEND _tmp_list "${arg}")
            endif()
        endif()
    endforeach()
    set(${list_name} ${_tmp_list})
    unset(_tmp_skip_next_arg)
    unset(_tmp_list)
endmacro()

# remove key and followings(usually to delete multiValueArgs), but not the multi values following p_KEEP
# Usage:
#   _ameba_list_remove_key_and_followings(<list_name> <key> [p_KEEP <keepvalue> ...])
function(_ameba_list_remove_key_and_followings list_name key)
    set(options)
    set(oneValueArgs)
    set(multiValueArgs p_KEEP)

    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    set(_tmp_list)
    set(_tmp_skip_next_arg FALSE)
    set(_tmp_find_keep FALSE)
    if(${list_name} STREQUAL "ARGN")
        message(FATAL_ERROR "list name should not be ARGN")
    endif()
    foreach(arg IN LISTS ${list_name})
        if ("${arg}_" STREQUAL "_")
            continue()
        endif()
        _ameba_list_contain(ARG_p_KEEP ${arg} is_contained)
        if (${is_contained})
            set(_tmp_find_keep TRUE)
        endif()

        if (_tmp_find_keep)
            list(APPEND _tmp_list "${arg}")
        else()
            if (NOT _tmp_skip_next_arg)
                if(${arg} STREQUAL "${key}")
                    set(_tmp_skip_next_arg TRUE)
                else()
                    list(APPEND _tmp_list "${arg}")
                endif()
            endif()
        endif()
    endforeach()
    set(${list_name} ${_tmp_list} PARENT_SCOPE)
endfunction()

function(_ameba_list_remove_before_keys list_name)
    set(options)
    set(oneValueArgs)
    set(multiValueArgs p_KEYS)
    cmake_parse_arguments(ARG "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    set(_tmp_list)
    set(_tmp_find_key FALSE)
    if(${list_name} STREQUAL "ARGN")
        message(FATAL_ERROR "list name should not be ARGN")
    endif()
    foreach(arg IN LISTS ${list_name})
        if ("${arg}_" STREQUAL "_")
            continue()
        endif()

        if (_tmp_find_key)
            list(APPEND _tmp_list ${arg})
        else()
            _ameba_list_contain(ARG_p_KEYS ${arg} is_contained)
            if (${is_contained})
                set(_tmp_find_key TRUE)
                list(APPEND _tmp_list ${arg})
            endif()
        endif()
    endforeach()
    set(${list_name} ${_tmp_list} PARENT_SCOPE)
endfunction()


# get target property to result, property should be [sources/compile_options/compile_defines/includes]
# if target is INTERFACE_LINK_LIBRARIES, than recursively get the property from the INTERFACE_LIBRARY, otherwise, just get the property from the target
# Usage:
#   ameba_target_get_property_recursive(<target> <property> <result>)
function(ameba_target_get_property_recursive target property result)
    if(${property} STREQUAL sources)
        set(property_name "INTERFACE_SOURCES")
    elseif(${property} STREQUAL compile_options)
        set(property_name "INTERFACE_COMPILE_OPTIONS")
    elseif(${property} STREQUAL compile_defines)
        set(property_name "INTERFACE_COMPILE_DEFINITIONS")
    elseif(${property} STREQUAL includes)
        set(property_name "INTERFACE_INCLUDE_DIRECTORIES")
    else()
        message(FATAL_ERROR "un-support property type for ameba_target_get_property_recursive: ${property}")
    endif()

    set(tmp_result)
    get_target_property(res ${target} ${property_name})
    if(res)
        list(APPEND tmp_result ${res})
    endif()

    get_target_property(libs ${target} INTERFACE_LINK_LIBRARIES)
    foreach(lib ${libs})
        if (TARGET ${lib})
            get_target_property(TARGET_TYPE ${lib} TYPE)
            if(${TARGET_TYPE} STREQUAL "INTERFACE_LIBRARY")
                ameba_target_get_property_recursive(${lib} ${property} res)
                if (res)
                    list(APPEND tmp_result ${res})
                endif()
            endif()
        endif()
    endforeach()

    set(${result} ${tmp_result} PARENT_SCOPE)
endfunction()
