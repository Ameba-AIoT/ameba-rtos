/*
 * Copyright (c) 2023, Arm Limited. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */

/*
 * Generated by erpcgen 1.9.1 on Fri Jul 21 17:28:31 2023.
 *
 * AUTOGENERATED - DO NOT EDIT
 */


#include "erpc_client_manager.h"
#if ERPC_ALLOCATION_POLICY == ERPC_ALLOCATION_POLICY_DYNAMIC
#include "erpc_port.h"
#endif
#include "erpc_codec.h"
extern "C"
{
#include "tfm_erpc.h"
}

#if 10901 != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif

using namespace erpc;
using namespace std;

extern ClientManager *g_client;

//! @brief Function to write struct binary_t
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data);

//! @brief Function to write struct list_binary_1_t
static void write_list_binary_1_t_struct(erpc::Codec * codec, const list_binary_1_t * data);


// Write struct binary_t function implementation
static void write_binary_t_struct(erpc::Codec * codec, const binary_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->writeBinary(data->dataLength, data->data);
}

// Write struct list_binary_1_t function implementation
static void write_list_binary_1_t_struct(erpc::Codec * codec, const list_binary_1_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->startWriteList(data->elementsCount);
    for (uint32_t listCount = 0U; listCount < data->elementsCount; ++listCount)
    {
        write_binary_t_struct(codec, &(data->elements[listCount]));
    }
}


//! @brief Function to read struct binary_t
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data);

//! @brief Function to read struct list_binary_1_t
static void read_list_binary_1_t_struct(erpc::Codec * codec, list_binary_1_t * data);


// Read struct binary_t function implementation
static void read_binary_t_struct(erpc::Codec * codec, binary_t * data)
{
    if(NULL == data)
    {
        return;
    }

    uint8_t * data_local;
    codec->readBinary(&data->dataLength, &data_local);
    memcpy(data->data, data_local, data->dataLength);
}

// Read struct list_binary_1_t function implementation
static void read_list_binary_1_t_struct(erpc::Codec * codec, list_binary_1_t * data)
{
    if(NULL == data)
    {
        return;
    }

    codec->startReadList(&data->elementsCount);
    for (uint32_t listCount = 0U; listCount < data->elementsCount; ++listCount)
    {
        read_binary_t_struct(codec, &(data->elements[listCount]));
    }
}



// psa_client_api interface psa_framework_version function client shim.
uint32_t psa_framework_version(void)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kpsa_client_api_service_id, kpsa_client_api_psa_framework_version_id, request.getSequence());

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kpsa_client_api_psa_framework_version_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = 0xFFFFFFFFU;
    }

    return result;
}

// psa_client_api interface psa_version function client shim.
uint32_t psa_version(uint32_t sid)
{
    erpc_status_t err = kErpcStatus_Success;

    uint32_t result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kpsa_client_api_service_id, kpsa_client_api_psa_version_id, request.getSequence());

        codec->write(sid);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kpsa_client_api_psa_version_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = 0xFFFFFFFFU;
    }

    return result;
}

// psa_client_api interface erpc_psa_call function client shim.
psa_status_t erpc_psa_call(psa_handle_t handle, int32_t t, const list_binary_1_t * erpc_in_vec, list_binary_1_t * erpc_out_vec)
{
    erpc_status_t err = kErpcStatus_Success;

    psa_status_t result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kpsa_client_api_service_id, kpsa_client_api_erpc_psa_call_id, request.getSequence());

        codec->write(handle);

        codec->write(t);

        write_list_binary_1_t_struct(codec, erpc_in_vec);

        write_list_binary_1_t_struct(codec, erpc_out_vec);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        read_list_binary_1_t_struct(codec, erpc_out_vec);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kpsa_client_api_erpc_psa_call_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = -1;
    }

    return result;
}

// psa_client_api interface psa_connect function client shim.
psa_handle_t psa_connect(uint32_t sid, uint32_t ver)
{
    erpc_status_t err = kErpcStatus_Success;

    psa_handle_t result;

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kpsa_client_api_service_id, kpsa_client_api_psa_connect_id, request.getSequence());

        codec->write(sid);

        codec->write(ver);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        codec->read(&result);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kpsa_client_api_psa_connect_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    if (err != kErpcStatus_Success)
    {
        result = -1;
    }

    return result;
}

// psa_client_api interface psa_close function client shim.
void psa_close(psa_handle_t handle)
{
    erpc_status_t err = kErpcStatus_Success;


#if ERPC_PRE_POST_ACTION
    pre_post_action_cb preCB = g_client->getPreCB();
    if (preCB)
    {
        preCB();
    }
#endif

    // Get a new request.
    RequestContext request = g_client->createRequest(false);

    // Encode the request.
    Codec * codec = request.getCodec();

    if (codec == NULL)
    {
        err = kErpcStatus_MemoryError;
    }
    else
    {
        codec->startWriteMessage(kInvocationMessage, kpsa_client_api_service_id, kpsa_client_api_psa_close_id, request.getSequence());

        codec->write(handle);

        // Send message to server
        // Codec status is checked inside this function.
        g_client->performRequest(request);

        err = codec->getStatus();
    }

    // Dispose of the request.
    g_client->releaseRequest(request);

    // Invoke error handler callback function
    g_client->callErrorHandler(err, kpsa_client_api_psa_close_id);

#if ERPC_PRE_POST_ACTION
    pre_post_action_cb postCB = g_client->getPostCB();
    if (postCB)
    {
        postCB();
    }
#endif


    return;
}
